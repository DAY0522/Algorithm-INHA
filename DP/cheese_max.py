p = [ # 9x9 미로 행렬
[-1, -1, 1, -1, -1, -1, -1, -1, -1],
[-1, -1, -1, -1, -1, 1, -1, 2, -1],
[1, -1, 2, -1, -1, -1, -1, 1, -1],
[-1, -1, -1, -1, 1, 2, -1, -1, -1],
[-1, 1, -1, 1, -1, -1, -1, -1, -1],
[-1, -1, -1, -1, -1, 2, 1, 2, -1],
[-1, 1, -1, -1, 1, -1, -1, -1, -1],
[-1, -1, -1, -1, -1, 1, -1, -1, -1],
[-1, -1, -1, -1, -1, -1, -1, -1, -1]]

cheese = [
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0]]

# 덫 처리
for r in range(9):
    for c in range(9):
        if p[r][c] == 2: # 덫
            p[r][c] = -9999999
        elif p[r][c] == -1: # 빈칸
            p[r][c] = 0

# 8행, 0열에 대한 치즈 수 미리 처리
# 한 방향에서만 올 수 있음
cheese[8][0] = p[8][0]

# 0열 처리
for i in range(7, -1, -1):
    cheese[i][0] = cheese[i+1][0] + p[i][0]

# 8행 처리
for i in range(1, 9):
    cheese[8][i] = cheese[8][i-1] + p[8][i]

# 나머지 공간 처리(두 방향에서 올 수 있음)
for r in range(7, -1, -1):
    for c in range(1, 9):
        cheese[r][c] = max(cheese[r+1][c], cheese[r][c-1]) + p[r][c] # recursive property

for d in cheese: # 각 위치에서 먹을 수 있는 치즈의 최댓값 출력
    print(d)
print(f'치즈 최댓값: {cheese[0][8]}')